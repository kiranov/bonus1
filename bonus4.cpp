/*
Данная задача является бонусной высокого уровня, она гарантирует вам +1.5 балла при чистом решении к 10-бальной оценке в конце
семестра в случае, если ваша оценка на тот момент будет >= уд(3).
Тем не менее дедлайн для отправки решений - 16 марта, 23:00.
Решать данную задачу на интерпретируемых языках не имеет смысла, так как они дадут просадку производительности "из коробки"
Желательно - С++, но готов рассматривать Go, Rust, C.
Неполные решения (например реализация лишь одного из алгоритмов, будут так же оценены, возможно в +0.5 -- +1 балл к итоговой)
*/

/*
    Хотя в нашем курсе класс задач и языков NP рассматривается как нечто трудное,
    что не стоит даже пытаться решать за полином, на практике подобные задачи решать все же приходится.
    Обычно используются различные эвристики, которые все так же плохи в худшем случае, как и полный перебор,
    но способные на большей части возможных входов давать быстрый ответ.
    В этот раз мы предлагаем вам решить задачу поиска клик в неориентированных графах без петель и кратных ребер,
    используя 2 различных алгоритма, а потом сравнить их результат.
    1. Детерминированный алгоритм, базирующийся на принципе meet-in-the-middle. На семинаре вам будет рассказано
        применение этой идеи для решения NP-полной задачи, несколько похожей на SUBSET-SUM (видимо, пока не будет, поэтому конспект в конце файла),
        а так же задачи дискретного логарифмирования: https://en.wikipedia.org/wiki/Baby-step_giant-step, он же -- Алгоритм Шенкса
        Вам стоит самостоятельно реализовать проверку работы реализации и замер времени работы. От вас ожидается, что граф на
        48 вершинах будет обрабатываться примерно секунду. (Мне с помощью алгоритмических и технических трюков, основанных
        на особенностях работы процессоров intel удалось обрабатывать 54 вершины за 0.8 секунд, сложность имеет вид ~2^(N/2) * N)
        Этот алгоритм показывает примерно одинаковое время работы на любых графах и не имеет сильно выраженных лучших и худших случаев.
    2. Эвристический алгоритм "Ветвей и границ", он же "Branches and bounds". Вот полезная статья на эту тему: https://bit.ly/2VwVGta.
        Эвристические алгоритмы позволяют осуществлять полный перебор с выбором некоторых приоритетных направлений, которые
        скорее всего и будут содержать решение. Не без ложки дегтя: для большинства эвристик существуют контрпримеры, для
        которых они показывают просто ужасные результаты, хоть и решают правильно.
        В практических задачах обычно сначала используется этот подход. В случае, если он не дает решения за некоторое время
        происходит смена алгоритма на другой.
*/

/*
    Граф стоит хранить в отдельном классе для обеспечения архитектуры и читаемости кода
*/

#include <vector>
#include <cstdint>
#include <iostream>
#include <cmath>
#include "stdint.h"

using namespace std;

class Graph {
public:
	size_t size;
	int** matrix;
public:
	Graph(){};
    Graph(size_t n_vertex){
		size = n_vertex;
		matrix = new int* [size];
		for(size_t i = 0; i < size; i++){
			matrix[i] = new int [size];
		}
		for(size_t i = 0; i < size; i++){
			for(size_t j = 0; j <= i; j++){
				matrix[i][j] = 0;
				matrix[j][i] = matrix[i][j];
			}
		}
		for(size_t i = 0; i < size; i++){
			matrix[i][i] = 1;
		}
		};
	void print(){
		for(size_t i = 0; i < size; i++){
			for(size_t j = 0; j < size; j++){
				cout << matrix[i][j] << " ";
			}
			cout << endl;
		}
	}
	
    void AddEdge(size_t from, size_t to){
			matrix[from][to] = 1;
			matrix[to][from] = matrix[from][to];
		};
	
    // Метод возвращает true, если в графе действительно есть клика размера заданного размера
    //virtual bool HasClique(size_t clique_size) = 0;

    // Метод возвращает размер максимальной клики для графа
    //virtual size_t GetMaxCliqueSize() = 0;

    // Метод возвращает вершины максимальной клики
    //virtual std::vector<size_t> GetMaxClique() = 0;
};

void Separate(Graph & G, Graph & G1, Graph & G2, Graph & G3){
		for(size_t i = 0; i < G1.size; i++){
			for(size_t j = 0; j <= i; j++){
				G1.matrix[i][j] = G.matrix[i][j];
				G1.matrix[j][i] = G.matrix[i][j];
			}
		}
		for(size_t i = 0; i < G2.size; i++){
			for(size_t j = 0; j <= i; j++){
				G2.matrix[i][j] = G.matrix[G.size - G2.size + i][G.size - G2.size + j];
				G2.matrix[j][i] = G.matrix[G.size - G2.size + i][G.size - G2.size + j];
			}
		}
		for(size_t i = 0; i < G3.size; i++){
			for(size_t j = 0; j < G3.size; j++){
				G3.matrix[i][j] = G.matrix[i][G.size/2+j];
			}
		}
};

void massive(Graph & G, uint64_t * arr){
		for(size_t i = 0; i < G.size; i++){
			arr[i] = 0;
		}
		for(size_t i = 0; i < G.size; i++){
			for(size_t j = 0; j < G.size; j++){
				arr[i] = arr[i] + G.matrix[i][j]*(pow(2,(G.size-j-1)));
			}
		}
};
/*
    От приведенного выше класса вам стоит унаследовать 2 потомков, первый будет предоставлять реализацию MITM
    алгоритма, а второй - эвристики.
    Определить способ хранения можно как в обоих потомках (возможно различным), но реализацию AddEdge и хранения графа
    я бы предложит реализовывать в Graph.
    На любые вопросы по С++ готов ответить в личке или после семинаров.
*/

class GraphMITM : public Graph {
    // ...
};

class GraphBRAB : public Graph {
    // ..
};

/*
int main(){
	int size;
	cin >> size; //5
	if(size % 2 != 0){
		size++;
	}
	Graph G(size);
	G.AddEdge(0,2);
	G.AddEdge(0,4);
	G.AddEdge(1,3);
	G.AddEdge(2,4);
	Graph G1(G.size/2);
	Graph G2(G.size/2);
	Graph G3(size - size/2);
	Separate(G, G1, G2, G3);
	uint64_t arr[G.size] = {0};
	cout << endl;
	massive(G, arr);
	for(size_t i = 0; i < G.size; i++){
		cout << arr[i] << endl;
	}
	cout << endl;
	G.print();
	G1.print();
	G2.print();
	G3.print();
	return 0;
}
*/
/*
    Задача, демонстрирующая еще один способ применения идеи MITM
    Условие:
        На вход программе подаются N целых чисел, нужно найти два непересекающихся непустых подмножества этих чисел таких,
        что суммы чисел каждого подмножества будут равны.
    Решение в лоб:
        Рассмотрим все N-значные числа в троичной системе исчисления, в каждом из них 0 на i позиции будет означать, что i число не взять,
        1 - что оно принадлежит первому подмножеству, 2 - второму. Для каждого числа проверим условие, что соответствующие подмножества не пусты и
        их суммы совпадают. Оценка сложности снизу -- \Omega(3^N), как перебор количества разбиений. На самом деле все еще немного хуже,
        так как для каждого разбиения нужно считать сумму.
    Решение по MITM:
        1. Разобьем числа на две группы по N/2. (если N нечетно, то группы будут отличаться размерном на 1)
        2. Для каждой группы построим аналогично предыдущему решению 3^(N/2) разбиений и вычислим их суммы, причем
            в этот раз включим в перебор и такие разбиения, где одно из множеств (а может и оба) будет пустым.
            Сохраним не обе суммы, а лишь только разность между ними вместе с описанием разбиений в массивы A и B.
            (А хранит пары <разбиение, разность сумм подмножеств> для первой половины всех чисел, B - для второй,
            итого их размеры в районе 3^(N/2))
        3. Отсортируем A и B по возрастанию и за линейное по их сумме длин время будем перебирать все пары a[i] \in A, b[i] \in B, таких,
            что a[i] == b[i].
        4. Чуть-чуть подумаем над процессом из п. 3 и выведем ответ.
        Идея: Если есть два равных числа в массивах, то a[l] = \sum_i A[s_i] - \sum_j A[k_j], то b[q] = \sum_r B[p_r] - \sum_t B[u_t],
            Тогда \sum_i A[s_i] + \sum_t B[u_t] = \sum_r B[p_r] + \sum_j A[k_j] - мы нашли два равных по сумме непересекающихся подмножества.
            Проверка на непустоту осуществляется отдельно.
*/
